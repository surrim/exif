<?php
// $Id:

/**
 * @author: Jean-Philippe Hautin
 * Adapted from exif module by Raphael SchÃ¤r - www.rapsli.ch, www.schaerwebdesign.ch
 * Changes:
 * - suppress need of 'sub-module' exif_helper
 * - update to use Drupal 7 Field API (new hook and logic)
 * - update to use Drupal 7 i18n nodes
 * - Support several field types
 *   - text field (as previous version)
 *   - term reference type (new !). This allow to
 *     - able to create terms (iptc and exif values)
 *     - able to create parent terms (iptc and exif field key)
 *
 */

function exif_menu() {
  $items['admin/config/media/exif'] = array(
    'title' => 'Images Metadata fields settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('exif_admin_settings_form'),
    'access arguments' => array('administer site configuration'),
    'description' => t('Images Metadata Settings'),
    'access callback' => 'user_access',
    'type' => MENU_LOCAL_TASK,
  );


  return $items;
}

/**
 * Implements hook_help().
 */
function exif_help($path, $arg) {
  drupal_add_css(drupal_get_path('module','exif') . '/exif.css');
  $filepath = drupal_get_path('module','exif') . '/sample.jpg';
  $exif = _exif_get_class();
  $fullmetadata = $exif->readMetadataTags($filepath);
  switch ($path) {
    case 'admin/help#exif':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Exif module allows you :');
      $output .= '<ul><li>' . t('extract metadata from an image'). '</li>';
      $output .= '<li>' . t('to classify your images by settings terms in taxonamy vocabulary'). '</li></ul>';
      $output .= t('To classify images, you define <em>vocabularies</em> that contain related <em>terms</em>, and then assign the vocabularies to content types. For more information, see the online handbook entry for the <a href="@taxonomy">Taxonomy module</a>.', array('@taxonomy' => 'http://drupal.org/handbook/modules/taxonomy/'));
      $output .= '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Creating vocabularies') . '</dt>';
      $output .= '<dd>' . t('Users with sufficient <a href="@perm">permissions</a> can create <em>vocabularies</em> through the <a href="@taxo">Taxonomy page</a>. The page listing the terms provides a drag-and-drop interface for controlling the order of the terms and sub-terms within a vocabulary, in a hierarchical fashion. A <em>controlled vocabulary</em> classifying music by genre with terms and sub-terms could look as follows:', array('@taxo' => url('admin/structure/taxonomy'), '@perm' => url('admin/config/people/permissions', array('fragment'=>'module-taxonomy'))));
      $output .= t('This module will automatically create in the chosen vocabulary (by default "Images"), the folowing structure:');
      $output .= '<ul><li>' . t ('<em>vocabulary</em>: Images'); '</li>';
      $output .= '<ul><li>' . t('<em>term</em>: iptc') . '</li>';
      $output .= '<ul><li>' . t('<em>sub-term</em>: keywords') . '</li>';
      $output .= '<ul><li>' . t('<em>sub-term</em>: Paris') . '</li>';
      $output .= '<li>' . t('<em>sub-term</em>: Friends') . '</li>';
      $output .= '</ul></ul>';
      $output .= '<ul><li>' . t('<em>sub-term</em>: caption') . '</li>';
      $output .= '<ul><li>' . t('<em>sub-term</em>: Le louvre') . '</li>';
      $output .= '</ul></ul></ul>';
      $output .= '<ul><li>' . t('<em>term</em>: exif') . '</li>';
      $output .= '<ul><li>' . t('<em>sub-term</em>: model') . '</li>';
      $output .= '<ul><li>' . t('<em>sub-term</em>: KINON DE800') . '</li>';
      $output .= '</ul></ul>';
      $output .= '<ul><li>' . t('<em>sub-term</em>: isospeedratings') . '</li>';
      $output .= '<ul><li>' . t('<em>sub-term</em>: 200') . '</li>';
      $output .= '</ul></ul></ul></ul>';
      $output .= '<dd>' . t('To get metadata information of an image, you have to choose on which node type the extraction should be made.');
      $output .=  t('You also have to create fields with specific names using the new Field UI.');
      $output .=  t('The type of the field can be :');
      $output .= '<ul><li>' . t ('<em>text field</em>: extract information and put it in the text field.'). '</li>';
      $output .= '<li>' . t ('<em>term reference field</em>: extract information, create terms and sub-terms if needed and put it in the field.').'</li>';
      $output .= '</ul>';
      $output .= t('Please, if you want to use term reference field, ensure :');
      $output .= '<ul><li>' . t('you choose the autocompletion widget and').'</li>';;
      $output .= '<li>' . t ('the "Images" Vocabulary exist.').'</li>';
      $output .= '</ul>';
      $output .=  t('TIPS : Note for iptc and exif fields that have several values (like field iptc "keywords" as an example), ');
      $output .=  t('if you want to get all the values, do not forget to configure the field to use unlimited number of values (by default, set to 1).');
      $output .= '</dd>';
      $output .= '</dl>';
      $output .= '<h3>' . t('Example of field name and the metadata extracted') . '</h3>';
      $rows = array();
      $help = '';
      if(is_array($fullmetadata)){
        foreach ($fullmetadata as $section => $section_data) {
          $rows[] = array('data'=>array($section,$help), 'class' => array('tag_type'));
          $section_data=_exif_reformat($section_data);
          foreach ($section_data as $key => $value) {
            if ($value != NULL && $value != '' && !_exif_startswith($key,'undefinedtag')) {
              $resultTag = "";
              if (is_array($value)) {
                foreach($value as $innerkey => $innervalue) {
                  if( ($innerkey+1) != count($value) )
                  $resultTag.=check_plain(utf8_encode($innervalue)).", ";
                  else
                  $resultTag.=check_plain(utf8_encode($innervalue));
                }
              } else {
                //$resultTag=check_plain(utf8_encode($value));
                $resultTag=check_plain(utf8_encode($value));
              }
              $rows[] = array('data'=>array("field_".$section."_".$key,check_plain(utf8_encode($resultTag))), 'class' => array('tag'));
            }
          }
        }
      }
      $header = array(t('Key'),t('Value'));
      $output .= '<p>';
      $variables = array ("header" => $header, "rows" => $rows, "attributes" => array(), "caption" => array(),"sticky" => array(), "colgroups" => array(), "empty" => array() );
      $output .= theme_table($variables);
      $output .= '</p>';
      return $output;
  }
}

/**
 * Implements hook_permission().
 */
function exif_permission() {
  return array(
    'administer image metadata' => array(
      'title' => t('Administer image metadata'),
  ),
  );
}

function _exif_node_insert_update($node) {
  $fields = field_info_instances('node',$node->type);
  //By default (and for now), module use the first field by alphabetic order in the default english language.
  // TODO : make GUI to define which field to use to look for the photo.
  //END
  if(_exif_check_for_exif_data($node->type)){
    $exif = _exif_get_class();
    $ar_exif_fields = $exif->getMetadataFields($fields);
    $field_image_name = _exif_get_image_field($fields);
    //first simple case, image field not found.
    if ($field_image_name == FALSE) {
      return FALSE;
    }
    //then check it is an array
    if (!is_array($node->$field_image_name)) {
      return FALSE;
    }
    $field_image = $node->$field_image_name;
    $language = _exif_get_image_language($field_image);
    if ($language == FALSE) {
      return FALSE;
    }
    $fid = _exif_get_image_fid($field_image,$language);
    if ($fid == FALSE) {
      return FALSE;
    }
    $file =  file_load($fid);
    $absoluteFilePath = drupal_realpath($file->uri);
    $fullmetadata = $exif->readMetadataTags($absoluteFilePath);
    $data = $exif->filterMetadataTags($fullmetadata,$ar_exif_fields);

    // prepare data to be stored in fields
    $i = 0;
    foreach ($data as $section => $section_data) {
      $section_data=_exif_reformat($section_data);
      foreach ($section_data as $key => $value) {
        if ($value != NULL) {
          $field_name = 'field_' . $section . "_" . $key;
          $tmp = $node->$field_name;
          if ($tmp == NULL) {
            $tmp = array($language => array() );
          }
          $value=_exif_prepare_date($key,$value);
          $field_type=$fields[$field_name];
          if (is_array($value)) {
            $j = 0 ;
            foreach($value as $innerkey => $innervalue) {
              _exif_handle_field($j,$language,$field_type,$tmp,$section,$key,$innervalue);
              $j++;
            }
          } else {
            _exif_handle_field(0,$language,$field_type,$tmp,$section,$key,$value);
          }
          $node->$field_name = $tmp;
          $i++;
        }
      }
    }
  }
}

/**
 * format value of exif value in case it is a date value.
 * @param unknown_type $exif_name
 * @param unknown_type $value
 * @return unknown_type
 */
function _exif_prepare_date($exif_name,$value) {
  //incase we get a datefield, we need to reformat it to the ISO 8601 standard:
  //which will look something like 2004-02-12T15:19:21
  $date_array = array('datetimeoriginal','datetime','datetimedigitized');
  if(in_array($exif_name,$date_array)){
    $date_time = explode(" ",$value);
    $date_time[0] = str_replace(":","-",$date_time[0]);
    if(variable_get('exif_granularity',0) == 1){
      $date_time[1] = "00:00:00";
    }
    $value = implode("T",$date_time);
  }
  return $value;
}

/**
 * handle field by delegating to specific type handler.
 * @param $index
 * @param $field_type
 * @param $field_data
 * @return unknown_type
 */
function _exif_handle_field($index,$language,$field_type,&$field_data,$exif_section,$exif_name,$exif_value) {
  if ($field_type['widget']['module']=='text') {
    _exif_handle_text_field($index,$language,$field_type,$field_data,$exif_section,$exif_name,$exif_value);
  } else if ($field_type['widget']['module']=='taxonomy') {
    _exif_handle_taxonomy_field($index,$language,$field_type,$field_data,$exif_section,$exif_name,$exif_value);
  }
}

/**
 * handle text field.
 * @param $index
 * @param $field_data
 * @return unknown_type
 */
function _exif_handle_text_field($index,$language,$field_type,&$field_data,$exif_section,$exif_name,$exif_value) {
  $field_data[$language][$index]['value'] = check_plain(utf8_encode($value));
}

/**
 * handle taxonomy field.
 * @param $terms
 * @param $field_data
 * @return unknown_type
 */
function _exif_handle_taxonomy_field($index,$language,$field_type,&$field_data,$exif_section,$exif_name,$exif_value)  {
  //TODO : check if the vocabulary is the same as the field
  //look for the term
  $terms = taxonomy_get_term_by_name($exif_value);
  if (is_array($terms) && count($terms)>0) {
    $term = array_shift($terms);
    $field_data[$language][$index]['tid'] = $term->tid;
  } else{
    //TODO: make auto-creation optional even if vocabulary exist.
    //TODO: add option to choose vocabulary
    // if not exist, create it
    //store full metadata in vocabulary
    $vocabularies = taxonomy_get_vocabularies();
    $chosen_vocabulary = variable_get('exif_vocabulary',0);
    if ($chosen_vocabulary != 0) {
      $terms = taxonomy_get_term_by_name($exif_name);
      if (is_array($terms) && count($terms)>0) {
        $parent_term = array_shift($terms);
      } else {
        $terms = taxonomy_get_term_by_name($exif_section);
        if (is_array($terms) && count($terms)>0) {
          $section_term = array_shift($terms);
        } else {
          $section_term = _exif_create_term($chosen_vocabulary,$exif_section);
        }
        $parent_term = _exif_create_term($chosen_vocabulary,$exif_name,$section_term->tid);
      }
      $term = _exif_create_term($chosen_vocabulary,$exif_value,$parent_term->tid);
      if (isset($term->tid)) {
        $field_data[$language][$index]['tid'] = $term->tid;
      }
    }
  }
}

/**
 *
 * @param $vid
 * @param $name
 * @param $parent_term
 * @return unknown_type
 */
function _exif_create_term($vid,$name,$parent_term = 0) {
  $term = new stdClass();
  $term->vid=$vid;
  $term->name=check_plain(utf8_encode($name));
  $term->parent=array($parent_term);
  taxonomy_term_save($term);
  return $term;
}

/**
 * implementation of hook_field_attach_presave
 *
 * calculate value for metadata field and set them before storage.
 *
 * @param String $obj_type The type of $object; e.g. 'node' or 'user'.
 * @param $object The object with fields to save.
 */
function exif_field_attach_presave($obj_type, $object) {
  if ($obj_type == 'node') {
    _exif_node_insert_update($object);
  }
}
/**
 * implementation of hook_field_attach_form.
 * remove metadata field from the form as it is programatically completed.
 *
 * @param $obj_type
 * @param $object
 * @param $form
 * @param $form_state
 * @param $langcode
 * @return unknown_type
 */
function exif_field_attach_form($obj_type, $object, &$form, &$form_state, $langcode) {
  if ($obj_type == 'node') {
    foreach ($form as $key => $value) {
      if (_exif_startswith($key,"field_iptc_") || _exif_startswith($key,"field_exif_") ) {
        unset($form[$key]);
      }
    }
  }
}

function _exif_startswith($hay, $needle) {
  return substr($hay, 0, strlen($needle)) === $needle;
}


/**
 * Let's check if this node type contains an image field.
 *
 * @param $fields fields from this content type
 * @return boolean
 */
function _exif_check_for_exif_data($node_type) {

  $new_types = array();
  //fill up array with checked nodetypes
  foreach (variable_get('exif_nodetypes', array()) as $type) {
    if ($type != "0" ) {
      $new_types[] = $type;
    }
  }
  if(in_array($node_type, $new_types)) {
    return TRUE;
  }
  return FALSE;
}

function _exif_get_image_field($fields) {
  foreach ($fields as $key => $value) {
    if (is_array($value) && is_array($value['widget']) && $value['widget']['type'] == 'image_image' ) {
      return $key;
    }
  }
  return FALSE;
}

function _exif_get_image_language($field) {
  if (array_key_exists('und',$field)) {
    return 'und';
  } else if (array_key_exists($node->language,$field)) {
    return $node->language;
  } else {
    return FALSE;
  }
}

function _exif_get_image_fid($field,$language) {
  if (is_array($field[$language]) && is_array($field[$language][0]) ) {
    $localized_field=$field[$language][0];
  } else  {
    return FALSE;
  }
  $fid=$localized_field['fid'];
  return $fid;
}

function exif_admin_settings_form() {
  $forms = array();
  $forms['exif_granularity'] = array(
		'#type'	=>	'select',
		'#title'=>	t('Granularity'),
		'#options'=> array(0=>t('Default'),1=>('Day')),
		'#default_value'=>variable_get('exif_granularity',0),
		'#description'=>t('If a timestamp is select (for example the date the picture was taken), you can specify here how granular the timestamp should be. If you select default it will just take whatever is available in the picture. If you select Day, the Date saved will look something like 13-12-2008. This can be useful if you want to use some kind of grouping on the data.'),
  );

  $all_nodetypes = node_type_get_types();
  $all_nt = array();
  foreach($all_nodetypes as $item){
    $all_nt[$item->type] = $item->name;
  }
  $forms['exif_nodetypes'] = array(
		'#type'	=>	'checkboxes',
		'#title'=>	t('Nodetypes'),
		'#options'=> $all_nt,
		'#default_value'=>variable_get('exif_nodetypes',array()),
		'#description'=> t('Select nodetypes which should be checked for itpc & exif data. In case the nodetypes contains more than one image field, the module will use the first one.'),
  );

  $all_vocabularies = taxonomy_get_vocabularies();
  $all_vocs = array();
  $all_vocs[0] = 'None';
  foreach($all_vocabularies as $item){
    $all_vocs[$item->vid] = $item->name;
  }
  $forms['exif_vocabulary'] = array(
		'#type'	=>	'select',
		'#title'=>	t('Vocabulary'),
		'#options'=> $all_vocs,
		'#default_value'=>variable_get('exif_vocabulary',array()),
		'#description'=> t('Select vocabulary which should be used for itpc & exif data.'),
  );

  return system_settings_form($forms);
}

/**
 * Helper function to reformat fields where required.
 *
 * Some values (lat/lon) break down into structures, not strings.
 * Dates should be parsed nicely.
 */
function _exif_reformat($data) {
  $date_array = array('datetimeoriginal', 'datetime', 'datetimedigitized');

  // Make the key lowercase as field names must be.
  $data = array_change_key_case($data, CASE_LOWER);
  foreach ($data as $key => &$value) {
    if (is_array($value))  {
      $value = array_change_key_case($value, CASE_LOWER);
    }
    if ($key == 'gps_latitude') {
      $value = _exif_reformat_DMS2D($value, $data['gps_gpslatituderef']);
    }
    elseif ($key == 'gps_longitude') {
      $value = _exif_reformat_DMS2D($value, $data['gps_gpslongituderef']);
    }
    elseif (in_array($key, $date_array)) {
      // In case we get a datefield, we need to reformat it to the ISO 8601 standard:
      // which will look something like 2004-02-12T15:19:21
      $date_time = explode(" ", $value);
      $date_time[0] = str_replace(":", "-", $date_time[0]);
      if (variable_get('exif_granularity', 0) == 1) {
        $date_time[1] = "00:00:00";
      }
      $value = implode("T", $date_time);
    } elseif ($key == 'usercomment') {
      if (_exif_startswith($value,'UNICODE')) {
        $value=substr($value,7);
      }
    }
  }
  return $data;
}

/**
 * Helper function to change GPS co-ords into decimals.
 */
function _exif_reformat_DMS2D($value, $ref) {
  $parts = split('/', $value[0]);
  $dec = $parts[0] / $parts[1];

  $parts = split('/', $value[1]);
  $dec += ($parts[0] / $parts[1]) / 60;

  $parts = split('/', $value[2]);
  $dec += ($parts[0] / $parts[1]) / 3600;

  if ($ref == 'S' || $ref == 'W') $dec *= -1;
  return $dec;
}

/**
 * Helper function to get the exif class
 * @return Exif
 */
function _exif_get_class() {
  include_once drupal_get_path('module', 'exif') .'/exif.class.php';
  $exif = Exif::getInstance();
  return $exif;
}
