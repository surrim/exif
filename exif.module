<?php
// $Id:

/**
 * @author: Jean-Philippe Hautin
 * Adapted from exif module by Raphael SchÃ¤r - www.rapsli.ch, www.schaerwebdesign.ch
 * Changes:
 * - suppress need of 'sub-module' exif_helper
 * - update to use Drupal 7 Field API (new hook and logic)
 * - update to use Drupal 7 i18n nodes
 * - Support several field types
 *   - text field (as previous version)
 *   - term reference type (new !). This allow to
 *     - able to create terms (iptc and exif values)
 *     - able to create parent terms (iptc and exif field key)
 *
 */

function exif_menu() {
  $items['admin/config/media/exif'] = array(
    'title' => 'Image Metadata',
    'page callback' => 'exif_admin_settings',
    'access arguments' => array('administer site configuration'),
    'description' => t('Display available fields'),
    'access callback' => 'user_access',
    'file' => 'exif.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/config/media/exif/general'] = array(
    'title' => 'Image Metadata',
    'page callback' => 'exif_admin_settings',
    'access arguments' => array('administer site configuration'),
    'description' => t('Display available fields'),
    'access callback' => 'user_access',
    'file' => 'exif.admin.inc',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );	
  $items['admin/config/media/exif/config'] = array(
    'title' => 'Image Metadata fields settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('exif_admin_settings_form'),
    'access arguments' => array('administer site configuration'),
    'description' => t('Images Metadata Settings'),
    'access callback' => 'user_access',
  	'file' => 'exif.admin.inc',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  return $items;
}

/**
 * Implements hook_help().
 */
function exif_help($path, $arg) {
	include_once drupal_get_path('module', 'exif'). '/exif.admin.inc';
  switch ($path) {
    case 'admin/help#exif':	return exif_admin_settings();
  }
}

/**
 * Implements hook_permission().
 */
function exif_permission() {
  return array(
    'administer image metadata' => array(
      'title' => t('Administer image metadata'),
  ),
  );
}

function _exif_node_insert_update($node) {
  $fields = field_info_instances('node',$node->type);
  //By default (and for now), module use the first field by alphabetic order in the default english language.
  // TODO : make GUI to define which field to use to look for the photo.
  //END
  if(_exif_check_for_exif_data($node->type)){
    $exif = _exif_get_class();
    $ar_exif_fields = $exif->getMetadataFields( $fields);
    $field_image_name = _exif_get_image_field($fields);
    //first simple case, image field not found.
    if ($field_image_name == FALSE) {
      return FALSE;
    }
    //then check it is an array
    if (!is_array($node->$field_image_name)) {
      return FALSE;
    }
    $field_image = $node->$field_image_name;
    $language = _exif_get_image_language($node,$field_image);
    if ($language == FALSE) {
      return FALSE;
    }
    $fid = _exif_get_image_fid($field_image,$language);
    if ($fid == FALSE) {
      return FALSE;
    }
    $file =  file_load($fid);
    $absoluteFilePath = drupal_realpath($file->uri);
    $fullmetadata = $exif->readMetadataTags($absoluteFilePath);
    $data = $exif->filterMetadataTags($fullmetadata,$ar_exif_fields);

    // prepare data to be stored in fields
    $i = 0;
    foreach ($data as $section => $section_data) {
      $section_data=_exif_reformat($section_data);
      foreach ($section_data as $key => $value) {
        if ($value != NULL) {
          $field_name = 'field_' . $section . "_" . $key;
          $tmp = $node->$field_name;
          if ($tmp == NULL) {
            $tmp = array($language => array() );
          }
          $value=_exif_prepare_date($key,$value);
          $field_type=$fields[$field_name];
          if (is_array($value)) {
            $j = 0 ;
            foreach($value as $innerkey => $innervalue) {
              _exif_handle_field($j,$language,$field_type,$tmp,$section,$key,$innervalue);
              $j++;
            }
          } else {
            _exif_handle_field(0,$language,$field_type,$tmp,$section,$key,$value);
          }
          $node->$field_name = $tmp;
          $i++;
        }
      }
    }
  }
}

/**
 * format value of exif value in case it is a date value.
 * @param unknown_type $exif_name
 * @param unknown_type $value
 * @return unknown_type
 */
function _exif_prepare_date($exif_name,$value) {
  //incase we get a datefield, we need to reformat it to the ISO 8601 standard:
  //which will look something like 2004-02-12T15:19:21
  $date_array = array('datetimeoriginal','datetime','datetimedigitized');
  if(in_array($exif_name,$date_array)){
    $date_time = explode(" ",$value);
    $date_time[0] = str_replace(":","-",$date_time[0]);
    if(variable_get('exif_granularity',0) == 1){
      $date_time[1] = "00:00:00";
    }
    $value = implode("T",$date_time);
  }
  return $value;
}

/**
 * handle field by delegating to specific type handler.
 * @param $index
 * @param $field_type
 * @param $field_data
 * @return unknown_type
 */
function _exif_handle_field($index,$language,$field_type,&$field_data,$exif_section,$exif_name,$exif_value) {
  if ($field_type['widget']['module']=='text') {
    _exif_handle_text_field($index,$language,$field_type,$field_data,$exif_section,$exif_name,$exif_value);
  } else if ($field_type['widget']['module']=='taxonomy') {
    _exif_handle_taxonomy_field($index,$language,$field_type,$field_data,$exif_section,$exif_name,$exif_value);
  }
}

/**
 * handle text field.
 * @param $index
 * @param $field_data
 * @return unknown_type
 */
function _exif_handle_text_field($index,$language,$field_type,&$field_data,$exif_section,$exif_name,$exif_value) {
  $field_data[$language][$index]['value'] = check_plain(utf8_encode($value));
}

/**
 * handle taxonomy field.
 * @param $terms
 * @param $field_data
 * @return unknown_type
 */
function _exif_handle_taxonomy_field($index,$language,$field_type,&$field_data,$exif_section,$exif_name,$exif_value)  {
  //TODO : check if the vocabulary is the same as the field
  //look for the term
  $terms = taxonomy_get_term_by_name($exif_value);
  if (is_array($terms) && count($terms)>0) {
    $term = array_shift($terms);
    $field_data[$language][$index]['tid'] = $term->tid;
  } else{
    //TODO: make auto-creation optional even if vocabulary exist.
    //TODO: add option to choose vocabulary
    // if not exist, create it
    //store full metadata in vocabulary
    $vocabularies = taxonomy_get_vocabularies();
    $chosen_vocabulary = variable_get('exif_vocabulary',0);
    if ($chosen_vocabulary != 0) {
      $terms = taxonomy_get_term_by_name($exif_name);
      if (is_array($terms) && count($terms)>0) {
        $parent_term = array_shift($terms);
      } else {
        $terms = taxonomy_get_term_by_name($exif_section);
        if (is_array($terms) && count($terms)>0) {
          $section_term = array_shift($terms);
        } else {
          $section_term = _exif_create_term($chosen_vocabulary,$exif_section);
        }
        $parent_term = _exif_create_term($chosen_vocabulary,$exif_name,$section_term->tid);
      }
      $term = _exif_create_term($chosen_vocabulary,$exif_value,$parent_term->tid);
      if (isset($term->tid)) {
        $field_data[$language][$index]['tid'] = $term->tid;
      }
    }
  }
}

/**
 *
 * @param $vid
 * @param $name
 * @param $parent_term
 * @return unknown_type
 */
function _exif_create_term($vid,$name,$parent_term = 0) {
  $term = new stdClass();
  $term->vid=$vid;
  $term->name=check_plain(utf8_encode($name));
  $term->parent=array($parent_term);
  taxonomy_term_save($term);
  return $term;
}

/**
 * implementation of hook_field_attach_presave
 *
 * calculate value for metadata field and set them before storage.
 *
 * @param String $obj_type The type of $object; e.g. 'node' or 'user'.
 * @param $object The object with fields to save.
 */
function exif_field_attach_presave($obj_type, $object) {
  if ($obj_type == 'node' && variable_get('exif_update', TRUE)) {
    _exif_node_insert_update($object);
  }
}
/**
 * implementation of hook_field_attach_form.
 * remove metadata field from the form as it is programatically completed.
 *
 * @param $obj_type
 * @param $object
 * @param $form
 * @param $form_state
 * @param $langcode
 * @return unknown_type
 */
function exif_field_attach_form($obj_type, $object, &$form, &$form_state, $langcode) {
  if ($obj_type == 'node') {
  	include_once drupal_get_path('module', 'exif') .'/exif.class.php';
    foreach ($form as $key => $value) {
      $sections = Exif::getMetadataSections();
      foreach ($sections as $key2 => $value2 ) {
	    if (_exif_startswith($key,"field_".$value2."_") || _exif_startswith($key,"field_".$value2."_") ) {
	      unset($form[$key]);
	    }      	
      }
    }
  }
}

function _exif_startswith($hay, $needle) {
  return substr($hay, 0, strlen($needle)) === $needle;
}

/**
 * Date API hook.
 *
 * Make exif a date format in Date API. This makes it possible to alter the
 * format exif dates is parsed as.
 */
function exif_date_format_types() {
  return array('exif' => 'EXIF');
}

/**
 * Date API hook.
 *
 * Make the EXIF date format default for the 'exif' date type.
 */
function exif_date_formats() {
  return array(
  array(
      'type' => 'exif',
      'format' => 'Y:m:d H:i:s',
  ),
  );
}

/**
 * Helper function to handle all date values from exif header. This is
 * designed for the date_api and date modules, but is compatible if these
 * aren't enabled.
 *
 * @param array $field
 *   The field definition for the matcing exif date
 * @param string $exif_date
 *   The date extracted from exif header.
 * @return array
 *   The field value array for delta = 0
 */
function _exif_date_handler($field, $exif_date) {
  if (! module_exists('date_api')) {
    // Don't bother doing anything if the webmaster doesn't ...
    return array('value' => $exif_date);
  }

  require_once drupal_get_path('module', 'date_api') .'/date_api_elements.inc';
  $date_datetime = date_convert_from_custom($exif_date, variable_get('date_format_exif', 'Y:m:d H:i:s'));
  if (! in_array($field['type'], array('date', 'datetime', 'datestamp'))) {
    // Field is not a date field type, so we return a ISO-8601 representation
    return array('value' => date_convert($date_datetime, DATE_DATETIME, DATE_ISO));
  }

  // Exif doesn't handles timezones, so we assume the exif date is in the
  // timezone configured for this date field.  This means the exif date needs
  // to be converted to UTC before it's stored.
  $timezone = date_get_timezone($field['tz_handling']);
  $date = date_make_date($date_datetime, $timezone, DATE_DATETIME, $field['granularity']);

  // Store date offset before converting to UTC as this is lost when setting
  // timezone to 'UTC'.
  $offset = date_offset_get($date);
  date_timezone_set($date, timezone_open('UTC'));

  // Finally, convert the date object in UTC to a date according to the field
  // type: DATE_ISO, DATE_DATETIME or DATE_UNIX.
  $date_field = date_convert($date, DATE_OBJECT, $field['type']);
  return array(
    'value' => $date_field,
    'value2' => $date_field,
    'timezone' => $timezone,
    'offset' => $offset,
    'offset2' => $offset,
  );
}
/**
 * Let's check if this node type contains an image field.
 *
 * @param $fields fields from this content type
 * @return boolean
 */
function _exif_check_for_exif_data($node_type) {

  $new_types = array();
  //fill up array with checked nodetypes
  foreach (variable_get('exif_nodetypes', array()) as $type) {
    if ($type != "0" ) {
      $new_types[] = $type;
    }
  }
  if (in_array($node_type, $new_types)) {
    return TRUE;
  }
  return FALSE;
}

function _exif_get_image_field($fields) {
  foreach ($fields as $key => $value) {
    if (is_array($value) && is_array($value['widget']) && $value['widget']['type'] == 'image_image' ) {
      return $key;
    }
  }
  return FALSE;
}

function _exif_get_image_language($node,$field) {
  if (array_key_exists($node->language,$field)) {
    return $node->language;    
  } else   if (array_key_exists('und',$field)) {
    return 'und'; 
  } else {
    return FALSE;
  }
}

function _exif_get_image_fid($field,$language) {
  if (is_array($field[$language]) && is_array($field[$language][0]) ) {
    $localized_field=$field[$language][0];
  } else  {
    return FALSE;
  }
  $fid=$localized_field['fid'];
  return $fid;
}

/**
 * Helper function to reformat fields where required.
 *
 * Some values (lat/lon) break down into structures, not strings.
 * Dates should be parsed nicely.
 */
function _exif_reformat($data) {
  $date_array = array('datetimeoriginal', 'datetime', 'datetimedigitized');

  // Make the key lowercase as field names must be.
  $data = array_change_key_case($data, CASE_LOWER);
  foreach ($data as $key => &$value) {
    if (is_array($value))  {
      $value = array_change_key_case($value, CASE_LOWER);
      
    }
    if ($key == 'gps_latitude') {
      $value = _exif_reformat_DMS2D(check_plain($value), $data['gps_gpslatituderef']);
    }
    elseif ($key == 'gps_longitude') {
      $value = _exif_reformat_DMS2D(check_plain($value), $data['gps_gpslongituderef']);
    }
    elseif (in_array($key, $date_array)) {
      // In case we get a datefield, we need to reformat it to the ISO 8601 standard:
      // which will look something like 2004-02-12T15:19:21
      $date_time = explode(" ", $value);
      $date_time[0] = str_replace(":", "-", $date_time[0]);
      if (variable_get('exif_granularity', 0) == 1) {
        $date_time[1] = "00:00:00";
      }
      $value = implode("T", $date_time);
    } elseif ($key == 'usercomment') {
      if (_exif_startswith($value,'UNICODE')) {
      	$value=substr($value,7);
      }
    }
  }
  return $data;
}

/**
 * Helper function to change GPS co-ords into decimals.
 */
function _exif_reformat_DMS2D($value, $ref) {
  $parts = split('/', $value[0]);
  $dec = (float) ((float) $parts[0] /  (float) $parts[1]);

  $parts = split('/', $value[1]);
  $dec += (float) (((float) $parts[0] /  (float) $parts[1]) / 60);

  $parts = split('/', $value[2]);
  $dec += (float) (((float) $parts[0] /  (float) $parts[1]) / 3600);

  if ($ref == 'S' || $ref == 'W') $dec *= -1;
  return $dec;
}

/**
 * Helper function to get the exif class
 * @return Exif
 */
function _exif_get_class() {
  include_once drupal_get_path('module', 'exif') .'/exif.class.php';
  $exif = Exif::getInstance();
  return $exif;
}

/**
 * Implementation of hook_hoken_list
 * @param array $type
 */
//function fast_gallery_token_list($type = 'node') {
//  if ($type == 'node') {
//    $exif = _exif_get_class();
//    $ar_iptc = $exif->getHumanReadableIPTCkey();
//    foreach ($ar_iptc as $iptc) {
//      $tokens['iptc']['iptc_' . $iptc] = 'IPTC Field: ' . $iptc;
//    }
//    return $tokens;
//  }
//}

/**
 * implementation of hook_token_values
 * @param unknown_type $type
 * @param unknown_type $object
 * @param unknown_type $options
 */
//function fast_gallery_token_values($type, $object = NULL, $options = array()) {
//  if ($type == 'node') {
//    $node = $object;
//    $exif = _exif_get_class();
//    $ar_iptc = $exif->getHumanReadableIPTCkey();
//
//    $info = content_types($node->type);
//    $fields = $info['fields'];
//    //get the path to the image
//    $image_path = _exif_get_image_path($fields, $node);
//    
//    dsm("start reading");
//    $iptc_values = $exif->readIPTCTags($image_path, array(), array('style' => 'fullSmall'));
//    dsm($iptc_values);
//
//    // TODO: needs to be finished
//    foreach ($iptc_values as $key => $iptc) {
//      $tokens['iptc_' . $key] = 'IPTC Field: ' . utf8_encode($iptc);
//    }
//    dsm($tokens);
//    return $tokens;
//  }
//}